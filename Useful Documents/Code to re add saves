Lexer.x
	"Spells"       { \s -> LTSpells }
	"Saves"        { \s -> LTSaves }
	"Fortitude"    { \s -> LTFortitude }
	"Reflex"       { \s -> LTReflex }
	"Will"         { \s -> LTWill }

LexerTokens.hs
  LTSpells         |
  LTSaves          |
  LTFortitude      |
  LTReflex         |
  LTWill           |
  
Parser.y
	Saves          { LTSaves }
	Fortitude      { LTFortitude }
	Reflex         { LTReflex }
	Will           { LTWill }
	
	     | Saves ':' SavesList                            { Saves $3 }
	     
SavesList : UnitSave                                      { [$1] }
          | UnitSave ',' SavesList                        { $1 : $3 }

UnitSave : Fortitude ':' Modifier                         { Fortitude $3 }
         | Reflex ':' Modifier                            { Reflex $3 }
         | Will ':' Modifier                              { Will $3 }

data SaveInput = 
     Fortitude Int |
     Reflex Int    |
     Will Int 
     deriving Show
     
|
	Saves [SaveInput]
	


UnitPlacement.hs
data UnitSaves = UnitSaves {
                     fortitude :: Int,
                     reflex :: Int,
                     will :: Int } 
                 deriving Show
unitSavesSize :: Int
unitSavesSize = 3

,
                     saves :: UnitSaves 
                     
|
                 SavesType UnitSaves

                           (SavesType saves)        = map M.! "Saves"
                           
                           ,
                                       saves = saves 

-- TO DO: Limpiar esta funciÃ³n, por el amor de Dios
buildUnitSaves :: [SaveInput] -> M.Map String Int -> Either String UnitSaves
buildUnitSaves [] map = if M.size map == unitSavesSize then Right (UnitSaves { fortitude = (map M.! "Fortitude"),
                                                                               reflex = (map M.! "Reflex"),
                                                                               will = (map M.! "Will") } )
                                                       else Left "Missing saves in unit "
buildUnitSaves ((Fortitude n) : ss) map = if M.member "Fortitude" map then Left "Duplicate Fortitude field in saves of unit "
                                                                      else buildUnitSaves ss (M.insert "Fortitude" n map)
buildUnitSaves ((Reflex n) : ss) map = if M.member "Reflex" map then Left "Duplicate Reflex field in saves of unit "
                                                                else buildUnitSaves ss (M.insert "Reflex" n map)
buildUnitSaves ((Will n) : ss) map = if M.member "Will" map then Left "Duplicate Will field in saves of unit "
                                                            else buildUnitSaves ss (M.insert "Will" n map)

buildStatBlock ((Saves ns) : ss) map = if M.member "Saves" map then Left "Duplicate Saves field in unit "
                                                               else case buildUnitSaves ns M.empty of
                                                                         Left errorMsg -> Left errorMsg
                                                                         Right unitSaves -> buildStatBlock ss (M.insert "Saves" (SavesType unitSaves) map)
                                                                         
